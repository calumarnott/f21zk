seed: 42
device: "cpu"  # will use "cuda" if available, don't change

# system dynamics parameters
system: "pendulum"
dynamics:
  params:
    m: 2.
    l: 1.
    c: 0.0
    g: 9.81
  dt: 0.01
  control_dt: 0.01 # controller update period (should be >= dt and a multiple of dt)
  integrator: "rk4"

controller:
  type: "pid"
  pid:
    # One axis for pendulum. Later you can add more keys for multi-axis systems.
    theta:
      Kp: 10.0
      Ki: 0.0
      Kd: 10.0
      u_min: -10.0
      u_max: 10.0
      setpoint: 0.0

# dataset parameters
data:
  n_trajectories: 5
  # initial_state:
  #   - [ 3.0,  0.0 ]   # theta, theta_dot. Add more states depending on the system
  #   # - [ 1.57,  0.0 ] # add more initial states (1 per trajectory)
  sim_time: 5 # in seconds. Alternatively, horizon: 2000 for fixed number of steps
  train_ratio: 0.8
  val_ratio: 0.1
  test_ratio: 0.1
  standardize: true

# model parameters
model:
  name: "mlp"
  hidden: [15, 15, 4] # hidden layer sizes
  dropout: 0.0

# training parameters
train:
  batch_size: 32
  epochs: 50
  lr: 1e-3
  show_val_progress: true
  show_test_progress: false
  adv:
    enabled: false       # turn on adversarial training
    method: "pgd"        # "pgd" or "fgsm"
    norm: "linf"         # "linf" or "l2"
    eps: 0.03
    steps: 10            # PGD only; FGSM ignores this
    alpha: null          # null -> eps/steps
    p: 1.0               # probability to attack a batch (0..1)
    mode: "replace"      # "replace" | "mix"
    mix_alpha: 0.5       # if mode="mix": loss = mix_alpha*adv + (1-mix_alpha)*clean
    start_epoch: 0       # wait N epochs before starting attacks (curriculum)
    save_samples: 16     # how many per epoch (0 to disable)
    save_every: 1        # epochs
    clip:
      enabled: false     # clip adv inputs to ranges (helpful if states have known bounds)
      lo: [-3.1416, -10.0]
      hi: [ 3.1416,  10.0]

verify:
  attack: "pgd"          # for a quick post-train adv eval
  norm: "linf"
  eps: 0.03
  steps: 40
  alpha: null
  n_samples: 256
